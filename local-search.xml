<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈Unmanaged</title>
    <link href="/2022/04/15/%E6%B5%85%E8%B0%88Unmanaged-md/"/>
    <url>/2022/04/15/%E6%B5%85%E8%B0%88Unmanaged-md/</url>
    
    <content type="html"><![CDATA[<p>最近学习Swift内存相关的东西，接触到了Unmanaged这个类型，在网上看了很多文档，个人感觉讲的比较晦涩，所以写下这篇笔记方便自己理解和总结。</p><p>Unmanaged解决的是在Swift中调用C函数时，C函数返回CoreFoundation类型的对象内存管理相关的问题，它的出现属于历史原因而作为临时的过渡方案。</p><p>在ARC下，所有的OC对象和从OC方法返回的CoreFoundation类型的对象都能由编译器自动管理内存。而通过C语言返回的CoreFoundation类型的对象仍然需要CFRetain、CFRelease来手动管理引用计数，或者桥接到OC对象上。</p><p>苹果通过在C函数命名中使用Create\Copy、Get字眼，让调用者明白返回的对象是否被调用者持有。比如我们调用包含Create\Copy的C函数返回的对象，需要我们对其使用CFRelease函数进行手动释放。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CFAttributedStringRef</span> attrStrRef = <span class="hljs-built_in">CFAttributedStringCreate</span>(kCFAllocatorDefault, (<span class="hljs-built_in">CFStringRef</span>)<span class="hljs-string">@&quot;Hello&quot;</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">CFRelease</span>(attrStrRef);<span class="hljs-comment">//需要手动释放</span><br></code></pre></td></tr></table></figure><p>而调用包含Get的C函数返回的对象则不需要手动释放，如果我们需要持有这个返回对象，则需要对其调用CFRetain函数。</p><p>Swift只支持ARC，所以没有retain、release这些方法，在Swift和OC混编的时候，编译器也能很好的帮我们自动管理内存，除了上面说的C函数返回CoreFundation对象。</p><p>举个例子，我们使用苹果的命名规范声明一个C函数：</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs obj-c"><span class="hljs-comment">//声明</span><br><span class="hljs-built_in">CFStringRef</span> CreateJoinedString(<span class="hljs-built_in">CFStringRef</span> s1, <span class="hljs-built_in">CFStringRef</span> s2);<br><br><span class="hljs-comment">//实现</span><br><span class="hljs-built_in">CFStringRef</span> CreateJoinedString(<span class="hljs-built_in">CFStringRef</span> s1, <span class="hljs-built_in">CFStringRef</span> s2) &#123;<br>    <span class="hljs-built_in">CFMutableStringRef</span> resultString = <span class="hljs-built_in">CFStringCreateMutableCopy</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, s1);<br>    <span class="hljs-built_in">CFStringAppend</span>(resultString, s2);<br>    <span class="hljs-keyword">return</span> resultString;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Swift中进行调用：</p><img src="/2022/04/15/%E6%B5%85%E8%B0%88Unmanaged-md/image1.png" class="" title="图1"><p>可以看到桥接到Swift中的方法的返回值是一个Unmanaged<CFString>!类型，为什么会返回这个类型？因为在OC中编译器都不能帮我们自动管理C函数返回的CoreFoundation对象，更别说Swift桥接调用C函数了。所以编译器这时候不知道如何管理这个C函数返回对象的引用计数，在翻译成Swift代码时将其包装成了Unmanaged类型的对象。这个类型现在只关注如下两个方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//都是取值，区别在于</span><br><span class="hljs-comment">//这个方法在取值时不会改变引用值的引用计数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeUnretainedValue</span>() -&gt; <span class="hljs-type">Instance</span><br><span class="hljs-comment">//这个方法返回引用值并对引用值进行一次release（引用计数减1）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeRetainedValue</span>() -&gt; <span class="hljs-type">Instance</span><br></code></pre></td></tr></table></figure><p>这其实就是将对象的内存管理交给调用者自己处理，相当于在Swift中变相提供了手动release操作。<em><strong>通过调用需要我们手动释放内存的函数而获得的对象时，使用takeRetainedValue进行取值，否则使用takeUnretainedValue</strong></em>，也就是苹果在CoreFoundation中使用Create&#x2F;Get命名方式的那些函数。</p><p>当然我们自己在写这种C函数时要避免在Swift中被包装成Unmanaged类型，可以使用<em><strong>CF_IMPLICIT_BRIDGING_ENABLED</strong></em>和<em><strong>CF_IMPLICIT_BRIDGING_DISABLED</strong></em>这两个宏将函数声明包裹起来，这是告诉clang编译器：不需要为Swift桥接审查和处理这些函数的CoreFoundation类型(即Annotated APIs，向编译器注明该方法可自动管理)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CF_IMPLICIT_BRIDGING_ENABLED</span><br><br><span class="hljs-built_in">CFStringRef</span> CreateJoinedString(<span class="hljs-built_in">CFStringRef</span> s1, <span class="hljs-built_in">CFStringRef</span> s2);<br><br><span class="hljs-built_in">CF_IMPLICIT_BRIDGING_DISABLED</span><br></code></pre></td></tr></table></figure><p>再回到Swift调用可以看到返回值不在是Unmanaged类型，而是C函数一样直接返回CFString</p><img src="/2022/04/15/%E6%B5%85%E8%B0%88Unmanaged-md/image2.png" class="" title="图2"><p>现在大部分CoreFoundation的方法都已经面向Swift进行了优化，返回值没有被Unmanaged包装，但还有部分API没有被注明可自动管理，比如AddressBook。</p><p>查看AddressBook的方法声明，可以看到很多方法的返回值类型是Unmanaged类型</p><img src="/2022/04/15/%E6%B5%85%E8%B0%88Unmanaged-md/image3.png" class="" title="图3"><p>可能由于苹果来不及对这些API进行处理吧，所以正如文初所说，Umagnage是因为历史原因（Swift 的API桥接OC的API，OC底层又是C的实现）和作为过渡方案的产物。随着Swift的完善，可能会越来越少甚至不会再见到这样的API。自己写的C函数要尽量避免这样的情况。</p><p>参考：<a href="https://nshipster.cn/unmanaged/">https://nshipster.cn/unmanaged/</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OC方法拦截器</title>
    <link href="/2020/06/16/OC%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2020/06/16/OC%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>##本文将介绍oc中的方法拦截器的实现思路，如何拦截一个方法，并在执行方法前进行一些前置业务逻辑后决定是否继续执行方法。</p><p>######缘由：最近公司需要将组件进行授权管理（类似第三方SDK的授权），之前编写过很多内部使用的SDK，现在需要将这些SDK通过授权管理起来，我的想法是编写一个统一授权管理的模块，需要被管理的SDK引用这个授权管理模块即可，要求是对原SDK尽量少做代码改动。<br>######在百度搜了一圈都没有想要的答案，所以决定自己提需求自己实现。</p><p>##需求：</p><p>1.对需要被拦截监听的方法无代码侵入。</p><p>2.成功拦截需要被监听的方法，并在方法执行前做前置逻辑判断，最后决定是否执行被拦截的方法。</p><p>##实现思路：</p><p>这么刁钻的需求肯定用runtime了，思路就是将被监听的方法的实例利用方法交换替换成自定义的方法，在自定义方法中执行我们自己的逻辑判断，最后决定是否需要继续原方法调用。（是不是很简单？上才艺！）</p><p>这里只讲实例方法的拦截，因为任何类都可能需要注册自己需要被监听的方法，所以创建一个NSObject的分类</p><p>##NSObject+SRModuleAuthorization.h:</p><figure class="highlight less"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-variable">@interface</span> NSObject (SRModuleAuthorization)<br><br>- (void)<span class="hljs-attribute">registerNeedMonitorSEL</span>:(SEL)sel;<br><br><span class="hljs-variable">@end</span><br><br></code></pre></td></tr></table></figure><p>头文件只对外暴露一个注册需要被监听方法的API。</p><p>##下面来看实现NSObject+SRModuleAuthorization.m:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//注册需要被拦截的方法</span><br>- (void)registerNeedMonitorSEL:(SEL)sel &#123;<br>    <span class="hljs-comment">//获取方法的名称，根据该名称设置自定义的方法名称</span><br>    NSString *methodName = <span class="hljs-constructor">NSStringFromSelector(<span class="hljs-params">sel</span>)</span>;<br>    NSString *newMethodName = <span class="hljs-literal">[NSS<span class="hljs-identifier">tring</span> <span class="hljs-identifier">stringWithFormat</span>:@&quot;<span class="hljs-identifier">sr_auth_</span>%@&quot;, <span class="hljs-identifier">methodName</span>]</span>;<br>    <span class="hljs-comment">//获取自定义方法的实例</span><br>    SEL newSel = <span class="hljs-constructor">NSSelectorFromString(<span class="hljs-params">newMethodName</span>)</span>;<br>    Method newMethod = <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceMethod([<span class="hljs-params">self</span> <span class="hljs-params">class</span>], <span class="hljs-params">newSel</span>)</span>;<br>    <span class="hljs-comment">//判断是否已经添加了自定义的方法，如果为空就添加自定义方法</span><br>    <span class="hljs-keyword">if</span> (!newMethod) &#123;<br>        <span class="hljs-comment">//获取被拦截方法的结构体对象</span><br>        Method <span class="hljs-keyword">method</span> = <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceMethod(<span class="hljs-params">self</span>.<span class="hljs-params">class</span>, <span class="hljs-params">sel</span>)</span>;<br>        <span class="hljs-comment">//获取被拦截方法的方法签名字符串</span><br>        const <span class="hljs-built_in">char</span> *functionType = <span class="hljs-keyword">method</span><span class="hljs-constructor">_getTypeEncoding(<span class="hljs-params">method</span>)</span>;<br>        NSString *functionTypeStr = <span class="hljs-literal">[NSS<span class="hljs-identifier">tring</span> <span class="hljs-identifier">stringWithUTF8String</span>:<span class="hljs-identifier">functionType</span>]</span>;<br>        <span class="hljs-comment">//判断方法签名的字符串中，:8是否是最后两个字符，</span><br>        <span class="hljs-comment">//如果是则代表无参数方法，否则是有参方法，</span><br>        <span class="hljs-comment">//针对这两种方法添加不同的自定义拦截方法。</span><br>        NSRange range = <span class="hljs-literal">[<span class="hljs-identifier">functionTypeStr</span> <span class="hljs-identifier">rangeOfString</span>:@&quot;:<span class="hljs-number">8</span>&quot;]</span>;<br>        Method intercetionMethod;<br>        <span class="hljs-keyword">if</span> (range.location + range.length &lt; functionTypeStr.length) &#123;<span class="hljs-comment">//有参的添加有参拦截方法</span><br>            intercetionMethod = <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceMethod(<span class="hljs-params">self</span>.<span class="hljs-params">class</span>, @<span class="hljs-params">selector</span>(<span class="hljs-params">interception</span>:)</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//添加无参拦截方法</span><br>            intercetionMethod = <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceMethod(<span class="hljs-params">self</span>.<span class="hljs-params">class</span>, @<span class="hljs-params">selector</span>(<span class="hljs-params">interception</span>)</span>);<br>        &#125;<br>        <span class="hljs-comment">//获取自定义拦截方法的实例，</span><br>        <span class="hljs-comment">//并将自定义方法的selector与实例关联，动态地添加进当前类型。</span><br>        IMP imp = <span class="hljs-keyword">method</span><span class="hljs-constructor">_getImplementation(<span class="hljs-params">intercetionMethod</span>)</span>;<br>        <span class="hljs-keyword">class</span><span class="hljs-constructor">_addMethod([<span class="hljs-params">self</span> <span class="hljs-params">class</span>], <span class="hljs-params">newSel</span>, <span class="hljs-params">imp</span>, <span class="hljs-params">functionType</span>)</span>;<br>        <span class="hljs-comment">//最后重新获取自定义方法的方法结构体，</span><br>        <span class="hljs-comment">//并与被监听方法进行实例交换，交换后，</span><br>        <span class="hljs-comment">//被监听的方法被调用时，就会执行我们自定义的方法实例，即interception</span><br>        Method method2 = <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceMethod(<span class="hljs-params">self</span>.<span class="hljs-params">class</span>, <span class="hljs-params">newSel</span>)</span>;<br>        <span class="hljs-keyword">method</span><span class="hljs-constructor">_exchangeImplementations(<span class="hljs-params">method</span>, <span class="hljs-params">method2</span>)</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是interception方法的实现，flag就理解为一个开关就行，interception的主要功能是决定是否需要执行被拦截的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//无参拦截方法</span><br>- (<span class="hljs-type">void</span>)interception &#123;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        <span class="hljs-built_in">NSString</span> *methodName = <span class="hljs-built_in">NSStringFromSelector</span>(_cmd);<br>        <span class="hljs-built_in">NSString</span> *newMethodName = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;dl_auth_%@&quot;</span>, methodName];<br>        SEL newSel = <span class="hljs-built_in">NSSelectorFromString</span>(newMethodName);<br>        <span class="hljs-built_in">NSMethodSignature</span> *signature = [[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] instanceMethodSignatureForSelector:newSel];<br>        <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:signature];<br>        invocation.target = <span class="hljs-keyword">self</span>;<br>        invocation.selector = newSel;<br>        [invocation invoke];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">//执行自定义代码</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>有参拦截方法的参数是一个可变参数列表，我们通过遍历并设置invocation对象的参数已达到传参的目的。<br>###注意：这里有个问题，被监听的方法中如果参数类型不是对象类型的话会报错，所以本文的方法拦截只适用于方法签名中参数都是对象类型的方法。（目前还没有找到能够解决的办法，如果你读到这里有更好的解决方案，希望你能告诉我）。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//有参拦截方法</span><br>- (<span class="hljs-type">void</span>)interception:(<span class="hljs-type">id</span>)param, ... &#123;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        <span class="hljs-built_in">NSString</span> *methodName = <span class="hljs-built_in">NSStringFromSelector</span>(_cmd);<br>        <span class="hljs-built_in">NSString</span> *newMethodName = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;dl_auth_%@&quot;</span>, methodName];<br>        SEL newSel = <span class="hljs-built_in">NSSelectorFromString</span>(newMethodName);<br>        <span class="hljs-built_in">NSMethodSignature</span> *signature = [[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] instanceMethodSignatureForSelector:newSel];<br>        <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:signature];<br>        invocation.target = <span class="hljs-keyword">self</span>;<br>        invocation.selector = newSel;<br>        <span class="hljs-built_in">NSInteger</span> argCount = signature.numberOfArguments;<br>        va_list args;<br>        va_start(args, param);<br>        <span class="hljs-built_in">NSMutableArray</span> *params = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        <span class="hljs-keyword">if</span> (argCount &gt; <span class="hljs-number">2</span>) &#123;<br>            [params addObject:param];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; argCount; i++) &#123;<br>            param = va_arg(args, <span class="hljs-type">id</span>);<br>            [params addObject:param];<br>        &#125;<br>        va_end(args);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; params.count; i++) &#123;<br>            <span class="hljs-type">id</span> obj = params[i];<br>            [invocation setArgument:&amp;obj atIndex:i + <span class="hljs-number">2</span>];<br>        &#125;<br>        [invocation invoke];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//执行自定义代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是我的统一授权组件的实现代码，使用的时候就很方便了，只需要在要被监听的类的初始化方法中，调用self的registerNeedMonitorSEL方法就行了，需要监听那个方法就监听哪个。<br>示例</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[<span class="hljs-keyword">self</span> <span class="hljs-symbol">registerNeedMonitorSEL:</span><span class="hljs-variable">@selector</span>(test)];<br></code></pre></td></tr></table></figure><p>你也可以编写一个监听所有方法的方法：<br>##注意：如果方法签名中有非对象的入参则会报错。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)registerNeedMonitorAllMethod &#123;<br>    unsigned <span class="hljs-built_in">int</span> count;<br>    Method *methodList = <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyMethodList([<span class="hljs-params">self</span> <span class="hljs-params">class</span>], &amp;<span class="hljs-params">count</span>)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        Method <span class="hljs-keyword">method</span> = methodList<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        SEL selector = <span class="hljs-keyword">method</span><span class="hljs-constructor">_getName(<span class="hljs-params">method</span>)</span>;<br>        <span class="hljs-literal">[<span class="hljs-identifier">self</span> <span class="hljs-identifier">registerNeedMonitorSEL</span>:<span class="hljs-identifier">selector</span>]</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用时一句代码搞定</span><br><span class="hljs-literal">[<span class="hljs-identifier">self</span> <span class="hljs-identifier">registerNeedMonitorAllMethod</span>]</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Objective-C笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>initWithString、initWithFormat及stringWithFormat的区别</title>
    <link href="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>其实这几个方法看似没啥区别，用的时候也很少在意，但最近无聊折腾了一下，却发现有些端倪。这里先说Apple的一个优化策略：Tagged Pointer，这里引用大神的文章： iOS Tagged Pointer - 简书。简单来说就是运行时让能用指针地址表达的值就用指针地址表达，不再单独分配内存地址，上个代码先：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image1.png" class="" title="图1"><p>以a的ascii码为基础，依次加一，然后根据新的ascii码生成字符串a、b、c…..i、j，并打印他们的相关信息，打印结果如下：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image2.png" class="" title="图2"><p>可以看到，通过stringWithFormat创建的字符串的类型是NSTaggedPointerString类型而不是__NSCFString或者__NSCFConstantString类型的。然后再看指针的地址，最后的两位应该是标识位，倒数第一位应该是指定值的类型，倒数第二位表示值的长度，剩下的61到6a是递增的，刚好符合上面代码ascii码的循环加一，61是“a”ascii码的十六进制表示，这就说明了运行时使用了Tagged Pointer技术。为啥要说这些乱七八糟的东西？因为我之前不知道有Tagged Pointer这个高级的东东，在测试NSString相关方法的时候踩了一些坑，所以特此介绍，免得看这篇文章的同学被坑进去，在测试的时候尽量用中文或者长字符串，这样就能够让系统在堆区中给字符串分配内存空间。😂</p><p>接下来回到正题，在使用字面量声明字符串的时候，字符串是放在常量区的，在编译阶段就已经确定，所以以下代码的变量无论声明多少都是引用常量区里面的同一个字符串。</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image3.png" class="" title="图3"><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image1.png" class="" title="图4 打印结果"><p>然后来看看stringWithFormat和initWithFormat，一个是类方法，一个是实例方法，stringWithFormat的内存管理方式是autorelease，initWithFormat则需要手动释放（ARC下不用处理，编译器帮我们完成了）。一眼看去好像差别不大。但是stringWithFormat在下面的代码中就有问题了：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image5.png" class="" title="图5"><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image6.png" class="" title="图6 内存监控"><p>内存出现了暴增的现象，这是由于stringWithFormat会在内部对创建的字符串做一次autorelease处理，这就导致了对象的延迟释放，因为这里有个for循环，那么autoreleasepool会等到runloop的当前循环结束后才会对释放池中的每个对象发送release消息，而runloop的当前循环结束的前提是要等for循环执行完，所以for循环内创建的对象就会在for循环执行完之前一直存在在内存中，导致暴增。再来看看initWithFormat：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image7.png" class="" title="图7"><p>这里编译器会有一个警告，提示你这是一个弱引用，会在单次循环结束后被释放（这里就已经能够说明问题了），接着我们来看看内存监控：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image8.png" class="" title="图8 内存监控"><p>并没有出现暴增的情况，也就是说initWithFormat创建的对象在ARC模式中，for的单次循环结束后就会release一次并被释放（MRC下手动管理）。</p><p>那么习惯使用stringWithFormat的同学就要注意点了，如果存在循环大量的创建字符串，要么我们尽量使用initWithString，非要用stringWithFormat怎么办？其实在循环内加个@autoreleasepool就好了（保证每次for循环都对对象release一次），就像下面这样：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image9.png" class="" title="图9"><p>最后，关于initWithString，这个方法如果你传的是字面量，那么编译器会提示你其实可以直接用字面量赋值，如果传的是变量或常量，我猜内部应该是返回的一个拷贝给你（参数是类型是NSString的话就是浅拷贝，NSMutableString就是深拷贝），内部代码我猜是这样的：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image10.png" class="" title="图10"><p>放个测试代码：</p><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image11.png" class="" title="图11"><img src="/2018/07/02/initWithString%E3%80%81initWithFormat%E5%8F%8AstringWithFormat%E7%9A%84%E5%8C%BA%E5%88%AB/image12.png" class="" title="图12"><p>主要看str2、str3、str4、str5，str2是字面量赋值的变量，所以值是在常量区，str3是用str2创建的，他们的地址是一样的，说明str3也是引用了常量区的值。str4的值是分配在堆区的，str5跟str4的地址一样，说明引用的是str4在堆中的值地址，所以我推测，initWithString内部只是做了一次copy。</p><p>sorry，废话有点多，就一个小的知识点，如果之前不知道，希望能帮到你，如果你对此非常了解并对我写的有不同的观点，希望能帮我指出不足或错误。</p>]]></content>
    
    
    <categories>
      
      <category>Objective-C笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift中使用KVC遇到的问题</title>
    <link href="/2018/03/22/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8KVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2018/03/22/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8KVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p> OC中使用KVC是因为NSObject遵循了NSKeyValueCoding协议，而OC中所有的类包括自定义类的根类都是NSObject，所以都能使用KVC特性，但是Swift中的类其实是没有统一的根类的（自定义一个类理论上也不需要继承任何父类），所以KVC可以说是OC中的特性，        </p><div class="code-wrapper"><pre><code class="hljs">要想在Swift中也使用KVC，我们就得将自定义的类继承NSObject（理论上遵循NSKeyValueCoding协议也是可以的，但没必要呀~）。但光是继承是不够的，比如下面这段代码：</code></pre></div><img src="/2018/03/22/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8KVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image1.png" class="" title="图1"><p>Example类已经继承自NSObject，这时候可以使用KVC功能获取title的值，但是第16行代码在调用的时候会抛出下面的运行时异常：</p><img src="/2018/03/22/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8KVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image2.png" class="" title="图2"><p>this class is not key value coding-compliant for the key xxxx，字面意思是没有找到与键为“xxxx”兼容的键值对，这就奇了怪了，明明定义了这个实例变量，这里却说找不到。</p><p>其实原因上面已经说到过了：KVC是OC的特性！</p><p>那么我们在Swift类中定义的实例变量OC肯定是没法访问的了，所以在调用value(forKey:)、setValue(forKey:)等KVC方法的时候就会报找不到的错。</p><p>解决方法：在实例变量的前面加上@objc进行修饰，如下：</p><img src="/2018/03/22/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8KVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image3.png" class="" title="图3"><p>这样就不会抛异常了。</p><p>解释下@objc的作用：</p><p>1.允许函数或属性通过OC的消息机制进行调用（即调用objc_msgSend，KVC其实也是基于runtime，swift貌似没有OC的runtime机制的，Swift是静态语言，不过可以间接使用runtime机制，后面再去花时间研究，所以上面问题的核心原理就在这里）</p><p>2.对Swift的函数或属性做一个面向OC的翻译，比如@objc func test()-&gt;Void{}这个方法就会被翻译成-(void)test{}</p><p>3.其他的就等你去发觉然后告诉我啦~~~</p>]]></content>
    
    
    <categories>
      
      <category>Swift笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
